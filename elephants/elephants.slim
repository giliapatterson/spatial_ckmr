initialize() {
	initializeSLiMModelType("nonWF");
	initializeSLiMOptions(keepPedigrees=T, dimensionality="xy");
	initializeSex("A");	
	if (!exists("SPAT_SAMP_OUT")) { 
      defineConstant("SPAT_SAMP_OUT", "spatial_sample.csv"); 
   }
   writeFile(SPAT_SAMP_OUT, paste(c("individual", "parent1", "parent2", "age", "sex", "year", "day", "x", "y"), sep = ","));
   if (!exists("SAMPLE_LOCS_OUT")) { 
      defineConstant("SAMPLE_LOCS_OUT", "spatial_sample_intensity.csv"); 
   }
   writeFile(SAMPLE_LOCS_OUT, "x,y");
   if (!exists("RAND_SAMP_OUT")) { 
      defineConstant("RAND_SAMP_OUT", "random_sample.csv"); 
   }
   writeFile(RAND_SAMP_OUT, paste(c("individual", "parent1", "parent2", "age", "sex", "year", "day", "x", "y"), sep = ","));
   if (!exists("POPSIZE_FILE")) { 
      defineConstant("POPSIZE_FILE", "popsize.csv"); 
   }
   writeFile(POPSIZE_FILE, "year,N");
   
   if (!exists("N0")) {
   	defineConstant("N0", 1000);
   }
   // Interaction distance for mate choice
   if (!exists("SIGMA")) {
   	defineConstant("SIGMA", 0.5);
   }
   // Interaction distance for one year of dispersal
   if (!exists("DISPERSAL_SIGMA")) {
   	defineConstant("DISPERSAL_SIGMA", 1.0);
   }
   if (!exists("NOFFSPRING")) {
   	defineConstant("NOFFSPRING", 1);
   }
   if (!exists("FAGEREPRO")) {
   	defineConstant("FAGEREPRO", 25);
   }
   if (!exists("MAGEREPRO")) {
   	defineConstant("MAGEREPRO", 30);
   }
   // Average number of adults in a group
   if (!exists("AVG_GROUP_SIZE")) {
   	defineConstant("AVG_GROUP_SIZE", 6);
   }
   // Age at which individuals can leave their maternal group
   if (!exists("MATURITY_AGE")) {
   	defineConstant("MATURITY_AGE", 15);
   }
   
	// Spatial mate choice
	initializeInteractionType(1, "xy", reciprocal=T, maxDistance=SIGMA, sexSegregation = "FM");
	// Interaction function for group reproduction
	initializeInteractionType(2, "xy", reciprocal=T, maxDistance=SIGMA);
	// Survival from life table
	survival = readCSV("survival.csv");
	defineConstant("SURVIVAL", survival);
	// Increase survival probabilities by raising to a power less than 1
	if (!exists("SURVIVAL_POWER")) {
   	defineConstant("SURVIVAL_POWER", 0.1);
   } 
   
   // Sampling size, times and locations
   // Number of individuals to sample at each time point
   defineConstant("SAMPLE_SIZE",  20);
   defineConstant("SAMPLE_YEARS",  200);
	defineConstant("SAMPLE_DAYS", c(0, 10, 20, 30));
	sampling_locations = asFloat(readFile("sampling_locations.txt"));
	defineConstant("SAMPLING_LOCATIONS", sampling_locations);
	// Sampling interaction function
	defineConstant("SAMPLE_SIGMA",  0.2);
	initializeInteractionType(3, "xy", reciprocal=T, maxDistance=SAMPLE_SIGMA);
	// Probability an individual within radius SAMPLE_SIGMA of a chosen sampling location is sampled
	defineConstant("PSAMPLE", 0.5);
		
	initializeMutationType("m1", 0.5, "f", 0.0);
	m1.convertToSubstitution = T;
	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElement(g1, 0, 99999);
	initializeMutationRate(0);
	initializeRecombinationRate(1e-8);
}
function (float)one_move(float x, float y, integer n, float dispersal_sigma){
	// n days of movement from coordinates (x, y)
	distance = sqrt(n*dispersal_sigma/365);
	max_tries = 20;
	new_pos = c(x, y) + rnorm(2, 0, distance);
	//new_pos = p1.pointUniform(1);
   // Is position within Kibale's bounds?
	inBounds = KIBALE.mapValue(new_pos) == 1.0;
	tries = 1;
	while (!inBounds & tries <= max_tries){
		new_pos = c(x, y) + rnorm(2, 0, distance);
		//new_pos = p1.pointUniform(1);
		inBounds = KIBALE.mapValue(new_pos) == 1.0;
		tries = tries + 1;
	}
	if (tries <= tries){
		return(new_pos);
	}
	else{
		print("20 tries all out of bounds");
		return(c(x, y));
	}
}

2: first() {
	i1.evaluate(p1);
}

reproduction(p1, "F") {
	// First check if female is old enough to breed	
	if(individual.age > FAGEREPRO){
		// Years since female last became pregnant
		// Could also check if offspring is alive
		years_since_last_rep = community.tick - individual.getValue("last_rep");
		if (years_since_last_rep > 6) {
			potential_mates = i1.nearestInteractingNeighbors(individual, length(p1.individuals));
			//print(potential_mates.size() + "interacting males");
			//potential_mates = p1.subsetIndividuals(sex = "M");
	   	if (potential_mates.size()){
   			m_a = potential_mates.age;
				p_mate = asInteger(m_a > MAGEREPRO);
				if(sum(p_mate) > 0){
	   			mate = sample(potential_mates, size = 1, weights = p_mate);
	   			individual.setValue("last_rep", community.tick);
	   			for (i in 1:NOFFSPRING){
	   				// Generate an offspring and put it in p3 (the population of unborn individuals)
	   				offspring1 = p3.addCrossed(individual, mate);
	   				// Assign offspring to mother
	   				offspring1.setValue("mother", individual.pedigreeID);
	      			if(offspring1.sex == "F"){
	      				offspring1.color = "pink";
	      				offspring1.setValue("last_rep", -6);
	      			}
	      			if(offspring1.sex == "M"){
	      				offspring1.color = "blue";
	      			}
	      		}
      		}
   		}
		}
	}	
}

reproduction(p2){
	members = p1.individuals[p1.individuals.getValue("group") == individual.pedigreeID];
	group_size = length(members);
	if(runif(1) < 1-exp(-group_size/AVG_GROUP_SIZE)){
		new_group = p2.addCloned(individual);
		// Change groups so parents follow groups and offspring follow parents
		new_members = sample(members, asInteger(group_size/2));
		new_members.setValue("group", new_group.pedigreeID);
		new_group.setSpatialPosition(individual.spatialPosition);
	}
}

1 early() {
	// Initial population
	sim.addSubpop("p1", N0);
	// Population of female groups
	// Each "individual" is a group
	ngroups = asInteger(N0/AVG_GROUP_SIZE);
	sim.addSubpop("p2", ngroups);
	// Population of unborn individuals
	sim.addSubpop("p3", 0);
   
   mapImage = Image("kibale.png");
   p1.setSpatialBounds(c(0.0, 0.0, 10, 10));
   p2.setSpatialBounds(c(0.0, 0.0, 10, 10));
   p3.setSpatialBounds(c(0.0, 0.0, 10, 10));
   map = p1.defineSpatialMap("kibale", "xy", 1.0-mapImage.floatK, valueRange = c(0.0, 1.0), colors = c("white", "green"));
   map2 = p2.defineSpatialMap("kibale2", "xy", 1.0-mapImage.floatK, valueRange = c(0.0, 1.0), colors = c("white", "green"));
   map3 = p3.defineSpatialMap("kibale2", "xy", 1.0-mapImage.floatK, valueRange = c(0.0, 1.0), colors = c("white", "green"));
   defineConstant("KIBALE", map);
   
   // Initial ages
   ages = 0:60;
   age_distribution = rep(1, 61);
   p1.individuals.age = sample(ages, N0, replace = T, weights = age_distribution);
   
   // Groups have random initial positions within the boundaries of kibale
   for (group in p2.individuals) {
   	// Generate new position uniformly
   	pos = p2.pointUniform();
   	// Is position within Kibale's bounds?
		inBounds = KIBALE.mapValue(pos) == 1.0;
		while (!inBounds){
			pos = p2.pointUniform();
			inBounds = KIBALE.mapValue(pos) == 1.0;
		}
		group.setSpatialPosition(pos);
   }
   
   // Females are assigned a group
   // Last year female bred is set
   females = p1.subsetIndividuals(sex = "F");
	for (fem in females){
		group = p2.sampleIndividuals(1);
		fem.setValue("group", group.pedigreeID);
		fem.setSpatialPosition(group.spatialPosition);
		fem.color = "pink";
		// Last year individual bred
		fem.setValue("last_rep" ,sample(-6:0, 1));
	};
	
	// Juvenile males are assigned a group
	juvenile_males = p1.subsetIndividuals(sex = "M", maxAge = MATURITY_AGE - 1);
	for (ind in juvenile_males){
		group = p2.sampleIndividuals(1);
		ind.setValue("group", group.pedigreeID);
		ind.setSpatialPosition(group.spatialPosition);
		ind.color = "blue";
	};	
   // Adult males are given a random location within kibale
   // Group is set to "none"
	adult_males = p1.subsetIndividuals(sex = "M", minAge = MATURITY_AGE);	
	for (ind in adult_males){
		ind.setValue("group", "none");
		ind.color = "blue";		
   		// Generate new position uniformly
   		pos = p1.pointUniform();
   		// Is position within Kibale's bounds?
		inBounds = KIBALE.mapValue(pos) == 1.0;			
		while (!inBounds){
			pos = p1.pointUniform();
			inBounds = KIBALE.mapValue(pos) == 1.0;
		}
		ind.setSpatialPosition(pos);
	};
}
early() {
	i2.evaluate(p2);

    // Age-based mortality
    for (ind in p1.individuals){
    	// Taking the square root to up survival
    	surv_prob = SURVIVAL.getValue(ind.sex)[ind.age]^SURVIVAL_POWER;
    	alive = runif(1) < surv_prob;
    	ind.fitnessScaling = asFloat(alive);
    }
    // Compute group size for everybody first and store as a property
    for (group in p2.individuals){
    	members = p1.individuals[p1.individuals.getValue("group") == group.pedigreeID];
	 	group_size = length(members);
	 	group.setValue("group_size", group_size);
    } 
    // Merge small groups into neighboring groups
    small_groups = p2.individuals[p2.individuals.getValue("group_size") <= 3];
    for (group in small_groups){
	 	neighbors = i2.nearestNeighbors(group);
	 	if(size(neighbors) > 0){
			neighbor_sizes = neighbors.getValue("group_size");
			new_group = sample(neighbors, 1, weights = 1/group_size);
			members = p1.individuals[p1.individuals.getValue("group") == group.pedigreeID];
			members.setValue("group", new_group.pedigreeID);
			old_size = new_group.getValue("group_size");
			new_group.setValue("group_size", old_size + group.getValue("group_size"));
			group.setValue("group_size", 0);
	 	}
	 }
	 // Eliminate empty groups
    p2.individuals.fitnessScaling = asFloat(p2.individuals.getValue("group_size") != 0);
    
    // Births
    unborn = p3.individuals;
    potential_births = unborn[unborn.age >=2];
    if(potential_births.size()){
    	// Loop through every potential birth
    	for(fetus in potential_births){
    		mother = sim.individualsWithPedigreeIDs(fetus.getValue("mother"),  p1);
    		// If mother is alive, transfer to p1 and set age to 0
    		// Set group to mother's group
    		if(mother.size()){
    			p1.takeMigrants(fetus);
    			fetus.age = 0;
				fetus.setValue("group", "juvenile");
				fetus.setSpatialPosition(mother.spatialPosition);
    		}
    		// If mother is dead, fetus dies
    		else{
    			fetus.fitnessScaling = 0.0;
    		}
    	}
	 }
}

late()
{
	// Is this a year where sampling takes place?
	sample_year = any(SAMPLE_YEARS == community.tick);
	// If it is a sampling year, dispersal happens every day days for one year
	if(sample_year){
		dispersal_days = 1;
	}
	// Otherwise, dispersal happens only once per year
	else{
		dispersal_days = 365;
	}
	periods = asInteger(365/dispersal_days);
	for (day in 1:periods){
		sample_day = any(SAMPLE_DAYS == day);
		if(sample_year & sample_day){
			sample = T;
		}
		else{
			sample = F;
		}
		// Group dispersal
		for (group in p2.individuals)
		{
			// Generate new position 
	   	pos = one_move(group.spatialPosition[0], group.spatialPosition[1], dispersal_days, DISPERSAL_SIGMA);
			group.setSpatialPosition(pos);
		}
		
		// Move individuals around
		for (ind in p1.individuals){
			group = ind.getValue("group");
			// Adult females follow group
			if(isNULL(group)){
				print("Error: Individual doesn't have a group");	
			}
			if(group != "none" & group != "juvenile"){
				ind.setSpatialPosition(sim.individualsWithPedigreeIDs(group).spatialPosition + rnorm(2, 0, 0.02));
			}
			// Juveniles follow mother or closest relative
			if(group == "juvenile"){
				mother = sim.individualsWithPedigreeIDs(ind.getValue("mother"), p1);
				//print(mother)
				// When mother is alive
				if(mother.size()){
					ind.setSpatialPosition(mother.spatialPosition + rnorm(2, 0, 0.02));
					// If juvenile has reached maturity, update group
					if (ind.age >= MATURITY_AGE){
						if(ind.sex == "F"){
							ind.setValue("group", mother.getValue("group"));
						}
						else{
							ind.setValue("group", "none");
						}
					}
				}
				// When mother is not alive, assign a close female relative as mother
				else{
					// Choose a random adult female with probability proportional to relatedness
					// Plus 1 in minAge is because group membership of females that became adults this year
					// haven't necessarily been updated
					adult_females = p1.subsetIndividuals(exclude = ind, sex = "F", minAge = MATURITY_AGE + 1);
					// Add a small number to relatedness for when no related females are alive
					relative = sample(adult_females, 1, weights = ind.relatedness(adult_females) + 0.001);
					ind.setSpatialPosition(relative.spatialPosition + rnorm(2, 0, 0.02));
					ind.setValue("mother", relative.pedigreeID);
					// If juvenile has reached maturity, update group
					if (ind.age >= MATURITY_AGE){
						if(ind.sex == "F"){
							ind.setValue("group", relative.getValue("group"));
						}
						else{
							ind.setValue("group", "none");
						}
					}
				}
			}
			// Individuals without a group (adult males) move around randomly
			if(group == "none"){
				pos = one_move(ind.spatialPosition[0], ind.spatialPosition[1], dispersal_days, DISPERSAL_SIGMA);
				ind.setSpatialPosition(pos);
			}
		}
		if(sample){
			// Sampling interaction function
			i3.evaluate(p1);
			total_sampled = 0;
			ntries = 0;
			while(total_sampled < SAMPLE_SIZE & ntries < 200){
				nsites = length(SAMPLING_LOCATIONS)/2;
				loc_i = asInteger(sample(0:(nsites-1), 1));
				loc = SAMPLING_LOCATIONS[c(loc_i*2, loc_i*2 + 1)];
				n_near = i3.neighborCountOfPoint(loc, p1);
				neighbors = i3.nearestNeighborsOfPoint(loc, p1,n_near);
				sampled_i = rbinom(n_near, 1, 0.5);
				sampled = neighbors[sampled_i==1];		
				total_sampled = total_sampled + length(sampled);
				print(loc);
				print(length(sampled));
				ntries + 1;
				writeFile(SAMPLE_LOCS_OUT, paste(loc, sep = ","), append = T);
				for(ind in sampled){
					writeFile(SPAT_SAMP_OUT, paste(c(ind.pedigreeID, ind.pedigreeParentIDs, ind.age, ind.sex, community.tick, day), sep = ",") + "," + paste(c(ind.x, ind.y), sep = ","), append = T);
				}
			}
			random_sample = p1.sampleIndividuals(SAMPLE_SIZE);
			for(ind in random_sample){
					writeFile(RAND_SAMP_OUT, paste(c(ind.pedigreeID, ind.pedigreeParentIDs, ind.age, ind.sex, community.tick, day), sep = ",") + "," + paste(c(ind.x, ind.y), sep = ","), append = T);
			}
		}
	}
	writeFile(POPSIZE_FILE, paste(c(community.tick, p1.individualCount), sep = ","), append = T);

	print("Late pop size");
	print(length(p1.individuals));
	print("Number of groups with individuals");
	groups = unique(p1.individuals.getValue("group"));
	print(length(groups));
	print("Average group size");
	total_group_size = 0;
	for(group in groups){
		members = p1.individuals[p1.individuals.getValue("group") == group];
		total_group_size = total_group_size + length(members);
	}
	print(total_group_size/length(groups));
}

10000 late() {
	sim.simulationFinished();
}
